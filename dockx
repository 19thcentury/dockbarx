#!/usr/bin/python

#   DockX
#
#	Copyright 2008, 2009, 2010 Aleksey Shaferov and Matias Sars
#
#	DockbarX is free software: you can redistribute it and/or modify
#	it under the terms of the GNU General Public License as published by
#	the Free Software Foundation, either version 3 of the License, or
#	(at your option) any later version.
#
#	DockbarX is distributed in the hope that it will be useful,
#	but WITHOUT ANY WARRANTY; without even the implied warranty of
#	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#	GNU General Public License for more details.
#
#	You should have received a copy of the GNU General Public License
#	along with dockbar.  If not, see <http://www.gnu.org/licenses/>.

from dockbarx.log import *
import sys
log_to_file()
sys.stderr = StdErrWrapper()
sys.stdout = StdOutWrapper()

import pygtk
pygtk.require("2.0")
import gtk
import cairo
import dockbarx.dockbar
import wnck
import gobject
from dockbarx.common import Globals
from Xlib import display
from math import pi
import weakref
import time
import dbus
import dbus.service

WNCK_WINDOW_STATE_MINIMIZED = 1


class CairoDockX(gtk.Window):
    """The Dock Window for running DockbarX as a standalone dock"""
    __gsignals__ = {"expose-event": "override"}
    def __init__(self):
        gtk.Window.__init__(self)
        self.globals = globals()
        self.set_type_hint(gtk.gdk.WINDOW_TYPE_HINT_DOCK)
        self.set_decorated(False)
        self.set_resizable(False)
        gtk_screen = gtk.gdk.screen_get_default()
        colormap = gtk_screen.get_rgba_colormap()
        if colormap is None:
            colormap = gtk_screen.get_rgb_colormap()
        self.set_colormap(colormap)
        self.set_app_paintable(1)
        self.globals = Globals()


    def do_expose_event(self, event):
        self.window.set_back_pixmap(None, False)
        self.set_shape_mask()
        w,h = self.get_size()
        self.ctx = self.window.cairo_create()
        # set a clip region for the expose event, XShape stuff
        self.ctx.save()
        if self.is_composited():
            self.ctx.set_source_rgba(1, 1, 1,0)
        else:
            self.ctx.set_source_rgb(0.8, 0.8, 0.8)
        self.ctx.set_operator(cairo.OPERATOR_SOURCE)
        self.ctx.paint()
        self.ctx.restore()
        self.ctx.rectangle(event.area.x, event.area.y,
                           event.area.width, event.area.height)
        self.ctx.clip()
        self.draw_frame(self.ctx, w, h)
        gtk.Window.do_expose_event(self, event)
        #~ if self.get_child():
            #~ self.propagate_expose(self.get_child(), event)

    def set_shape_mask(self):
        # Set window shape from alpha mask of background image
        #~ w,h = self.get_size()
        #~ if w==0: w = 800
        #~ if h==0: h = 600
        #~ pixmap = gtk.gdk.Pixmap (None, w, h, 1)
        #~ ctx = pixmap.cairo_create()
        #~ ctx.set_source_rgba(0, 0, 0,0)
        #~ ctx.set_operator (cairo.OPERATOR_SOURCE)
        #~ ctx.paint()
        #~ if self.is_composited():
            #~ make_path(ctx, 0, 0, w, h, 6, 0, 9, self.pointer, self.ap)
            #~ ctx.set_source_rgba(1, 1, 1, 1)
        #~ else:
            #~ make_path(ctx, 0, 0, w, h, 6, 1, 9, self.pointer, self.ap)
            #~ ctx.set_source_rgb(0, 0, 0)
        #~ ctx.fill()
        #~ self.shape_combine_mask(pixmap, 0, 0)
        #~ del pixmap
        pass

    def draw_frame(self, ctx, w, h):
        color = self.globals.colors["color1"]
        red = float(int(color[1:3], 16))/255
        green = float(int(color[3:5], 16))/255
        blue = float(int(color[5:7], 16))/255
        alpha= float(self.globals.colors["color1_alpha"]) / 255
        mode = self.globals.settings["dock/mode"]
        pos = self.globals.settings["dock/position"]
        r = 6
        # Create the stroke and fill paths
        if pos == "left":
            if mode == "centered":
                ctx.move_to(0, 0.5)
                ctx.arc(w - r - 0.5, r + 0.5, r, -pi/2, 0)
            else:
                ctx.move_to(w - 0.5, 0)
            if mode == "centered" or mode == "corner":
                ctx.arc(w - r - 0.5, h - r - 0.5, r, 0, pi/2)
                ctx.line_to(0, h - 0.5)
            else:
                ctx.line_to(w - 0.5, h)
            stroke_path = ctx.copy_path()
            ctx.line_to(0, h)
            ctx.line_to(0, 0)
            ctx.close_path()
        elif pos == "right":
            if mode == "centered":
                ctx.move_to(w, 0.5)
                ctx.arc_negative(r + 0.5, r + 0.5, r, -pi/2, -pi)
            else:
                ctx.move_to(0.5, 0)
            if mode == "centered" or mode == "corner":
                ctx.arc_negative(r + 0.5, h - r - 0.5, r, pi, pi/2)
                ctx.line_to(w, h - 0.5)
            else:
                ctx.line_to(0.5, h)
            stroke_path = ctx.copy_path()
            ctx.line_to(w, h)
            ctx.line_to(w, 0)
            ctx.close_path()
        elif pos == "top":
            if mode == "centered":
                ctx.move_to(0.5, 0)
                ctx.arc_negative(r + 0.5, h - r - 0.5, r, pi, pi/2)
            else:
                ctx.move_to(0, h - 0.5)
            if mode == "centered" or mode == "corner":
                ctx.arc_negative(w - r - 0.5, h - r - 0.5, r, pi/2, 0)
                ctx.line_to(w - 0.5, 0)
            else:
                ctx.line_to(w, h - 0.5)
            stroke_path = ctx.copy_path()
            ctx.line_to(w, 0)
            ctx.line_to(0, 0)
            ctx.close_path()
        else:
            if mode == "centered":
                ctx.move_to(0.5, h)
                ctx.arc(r + 0.5, r + 0.5, r, -pi, -pi/2)
            else:
                ctx.move_to(0, 0.5)
            if mode == "centered" or mode == "corner":
                ctx.arc(w - r - 0.5, r + 0.5, r, -pi/2, 0)
                ctx.line_to(w - 0.5, h)
            else:
                ctx.line_to(w, 0.5)
            stroke_path = ctx.copy_path()
            ctx.line_to(w, h)
            ctx.line_to(0, h)
            ctx.close_path()
        # Fill with background color
        if self.is_composited():
            ctx.set_source_rgba(red, green, blue, alpha)
        else:
            ctx.set_source_rgb(red, green, blue)
        ctx.fill()
        # Stroke the outer border
        ctx.append_path(stroke_path)
        if self.is_composited():
            ctx.set_source_rgba(red*0.5, green*0.5, blue*0.5, 0.8)
        else:
            ctx.set_source_rgb(red*0.5, green*0.5, blue*0.5)
        ctx.set_line_width(1)
        ctx.stroke()

        
class DockX(CairoDockX):
    __gsignals__ = {"destroy": "override",
                    "size-allocate": "override"}
    def __init__(self, monitor=0):
        self.globals = Globals()
        self.empty_space = {"left": 1000, "right": 1000,
                            "top": 1000, "bottom":1000}
        self.geometry_time = 0
        self.last_geometry_window = lambda: None
        self.monitor = monitor
        self.windows = weakref.WeakKeyDictionary()
        self.border_distances = weakref.WeakKeyDictionary()
        self.db_loaded = False
        self.dockbar = dockbarx.dockbar.DockBar(None,
                                                parent_window=self,
                                                run_as_dock=True)
        self.dockbar.load()
        self.db_loaded = True
        CairoDockX.__init__(self)
        self.set_keep_above(True)
        self.autohide_sid = None
        self.autounhide_sid = None
        self.autounhide_sid = None
        self.box = gtk.HBox()
        self.padding1 = EventPadding(self, "before")
        self.padding2 = EventPadding(self, "after")
        self.add(self.box)
        self.position_dock()
        self.globals.connect("dock-size-changed", self.position_dock)
        self.globals.connect("dock-position-changed",
                             self.__on_position_changed)
        self.globals.connect("dock-mode-changed", self.__on_mode_changed)
        self.globals.connect("dock-offset-changed", self.__on_offset_changed)
        self.globals.connect("dock-overlap-changed",
                             self.__on_overlap_changed)
        self.globals.connect("dock-autohide-changed",
                             self.__on_autohide_changed)
        self.__calc_window_overlaps()
        if self.globals.settings["dock/autohide"]:
            self.show_dock()
        self.dbus_obj = DockXDBus(self)

    def position_dock(self, *args):
        centered = self.globals.settings["dock/mode"] == "centered"
        cornered = self.globals.settings["dock/mode"] == "corner"
        pos = self.globals.settings["dock/position"]
        if self.globals.settings["dock/position"] in ("left", "right"):
            if self.dockbar.orient != "v" or not self.box.get_children():
                self.dockbar.set_orient("v")
                for child in self.box.get_children():
                    self.box.remove(child)
                self.box.destroy()
                self.box = gtk.VBox()
                self.add(self.box)
                self.box.pack_start(self.padding1, False, False)
                self.box.pack_start(self.dockbar.container, False, False)
                if centered or cornered:
                    self.box.pack_start(self.padding2, False, False)
                else:
                    self.box.pack_start(self.padding2, True, True)
                self.show_all()
        else:
            if self.dockbar.orient != "h" or not self.box.get_children():
                self.dockbar.set_orient("h")
                for child in self.box.get_children():
                    self.box.remove(child)
                self.box.destroy()
                self.box = gtk.HBox()
                self.add(self.box)
                if centered or cornered:
                    self.box.pack_start(self.padding1, False, False)
                self.box.pack_start(self.dockbar.container, False, False)
                if centered or cornered:
                    self.box.pack_start(self.padding2, False, False)
                else:
                    self.box.pack_start(self.padding2, True, True)
                self.show_all()
        mx, my, mw, mh = self.get_monitor_geometry()
        l, r, t, b = self.__get_monitor_and_strut_borders()
        sw = self.get_screen().get_width()
        sh = self.get_screen().get_height()
        size = self.globals.settings["dock/size"]
        o = self.globals.settings["dock/offset"]
        if pos == "left":
            x,y, w, h = (l, t + o, size, sh - t - b - o)
            strut = [x + w, 0, 0, 0, y, y + h - 1, 0, 0, 0, 0, 0, 0]
        elif pos == "right":
            x,y, w, h = (sw - size - r, t + o, size, sh - t - b - o)
            strut = [0, sw - x, 0, 0, 0, 0, y, y + h - 1, 0, 0, 0, 0]
            print x,y,w,h
        elif pos == "top":
            x,y, w, h = (l + o, t, sw - l - r - o, size)
            strut = [0, 0, y + h, 0, 0, 0, 0, 0, x, x + w - 1, 0, 0]
        else:
            x,y, w, h = (l + o, sh - size - b, sw - l - r - o, size)
            strut = [0, 0, 0, sh - y, 0, 0, 0, 0, 0, 0, x, x + w - 1]
        if (centered or cornered) and pos in ("left", "right"):
            self.set_size_request(w, -1)
        elif (centered or cornered):
            self.set_size_request(-1, h)
        else:
            self.set_size_request(w, h)
        if centered and pos in ("left", "right"):
            a = self.get_allocation()
            self.move(x, my + mh / 2 - a.height / 2)
        elif centered:
            a = self.get_allocation()
            self.move(mx + mw / 2 - a.width / 2, y)
        else:
            self.move(x, y)
        self.__set_dock_strut(x, y, w, h)
        for group in self.dockbar.groups:
            group.button.icon_factory.set_size(size)
            group.button.update_state(force_update=True)

    def __set_dock_strut(self, x, y, w, h):
        if not self.window:
            return
        set_strut = not self.globals.settings["dock/overlap"] \
                    and not self.globals.settings["dock/autohide"]
        if not set_strut:
            self.window.property_delete("_NET_WM_STRUT")
            self.window.property_delete("_NET_WM_STRUT_PARTIAL")
            return
        s = self.get_screen()
        sw = s.get_width()
        sh = s.get_height()
        mx, my, mw, mh = s.get_monitor_geometry(self.monitor)
        if self.globals.settings["dock/position"] == "left":
            strut = [x + w, 0, 0, 0, y, y + h - 1, 0, 0, 0, 0, 0, 0]
            # Make sure that there's no monitor on the left side of this one.
            if s.get_monitor_at_point(mx - 5, y + h / 2) != self.monitor:
                set_strut = False
        elif self.globals.settings["dock/position"] == "right":
            strut = [0, sw - x, 0, 0, 0, 0, y, y + h - 1, 0, 0, 0, 0]
            if s.get_monitor_at_point(mx + mw + 5, y + h / 2) != self.monitor:
                set_strut = False
        elif self.globals.settings["dock/position"] == "top":
            strut = [0, 0, y + h, 0, 0, 0, 0, 0, x, x + w - 1, 0, 0]
            if s.get_monitor_at_point(x + w / 2, my - 5) != self.monitor:
                set_strut = False
        else:
            strut = [0, 0, 0, sh - y, 0, 0, 0, 0, 0, 0, x, x + w - 1]
            if s.get_monitor_at_point(x + w / 2, my + mh + 5) != self.monitor:
                set_strut = False
        self.window.property_change("_NET_WM_STRUT", "CARDINAL", 32, 
                                    gtk.gdk.PROP_MODE_REPLACE, strut[:4])  
        self.window.property_change("_NET_WM_STRUT_PARTIAL", "CARDINAL", 
                                    32, gtk.gdk.PROP_MODE_REPLACE, strut)
            
    def __get_monitor_and_strut_borders(self):
        # This function returns the distance from screen edges to
        # the monitor edges including strut.
        size = self.globals.settings["dock/size"]
        mx, my, mw, mh = self.get_monitor_geometry()
        sw = self.get_screen().get_width()
        sh = self.get_screen().get_height()
        strut = [mx, sw - (mx + mw), my,  sh - (my + mh)]
        d = display.Display()
        strut_atom = d.get_atom('_NET_WM_STRUT')
        strut_partial_atom = d.get_atom('_NET_WM_STRUT_PARTIAL')
        root = d.screen().root
        windows = root.query_tree()._data['children']
        for w in windows:
            try:
                prop1 = w.get_full_property(strut_partial_atom, 0)
                prop2 = w.get_full_property(strut_atom, 0)
            except:
                continue
            if prop1 is not None:
                cl = w.get_wm_class()
                if cl and cl[0] in ("dockx", "dockbarx_factory"):
                    continue
                if self.globals.settings["dock/position"] == "left":
                    #~ if prop1.value[4] < my + mh and \
                       #~ prop1.value[5] >= my:
                        #~ strut[0] = max(strut[0], prop1.value[0])
                    if prop1.value[6] < my + mh and \
                       prop1.value[7] >= my:
                        strut[1] = max(strut[1], prop1.value[1])
                    if prop1.value[8] <= mx + size and \
                       prop1.value[9] >= mx:
                        strut[2] = max(strut[2], prop1.value[2])
                    if prop1.value[10] <= mx + size and \
                       prop1.value[11] >= mx:
                        strut[3] = max(strut[3], prop1.value[3])
                elif self.globals.settings["dock/position"] == "right":
                    if prop1.value[4] < my + mh and \
                       prop1.value[5] >= my:
                        strut[0] = max(strut[0], prop1.value[0])
                    #~ if prop1.value[6] < my + mh and \
                       #~ prop1.value[7] >= my:
                        #~ strut[1] = max(strut[1], prop1.value[1])
                    if prop1.value[8] < mx + mw and \
                       prop1.value[9] >= mx + mw - size:
                        strut[2] = max(strut[2], prop1.value[2])
                    if prop1.value[10] < mx + mw and \
                       prop1.value[11] >= mx + mw - size:
                        strut[3] = max(strut[3], prop1.value[3])
                elif self.globals.settings["dock/position"] == "top":
                    if prop1.value[4] <= my + size and \
                       prop1.value[5] >= my:
                        strut[0] = max(strut[0], prop1.value[0])
                    if prop1.value[6] <= my + size and \
                       prop1.value[7] >= my:
                        strut[1] = max(strut[1], prop1.value[1])
                    #~ if prop1.value[8] < mx + mw and \
                       #~ prop1.value[9] >= mx:
                        #~ strut[2] = max(strut[2], prop1.value[2])
                    if prop1.value[10] < mx + mw and \
                       prop1.value[11] >= mx:
                        strut[3] = max(strut[3], prop1.value[3])
                else:
                    if prop1.value[4] < my + mh and \
                       prop1.value[5] >= my + mh - size:
                        strut[0] = max(strut[0], prop1.value[0])
                    if prop1.value[6] < my + mh and \
                       prop1.value[7] >= my + mh - size:
                        strut[1] = max(strut[1], prop1.value[1])
                    if prop1.value[8] < mx + mw and \
                       prop1.value[9] >= mx:
                        strut[2] = max(strut[2], prop1.value[2])
                    #~ if prop1.value[10] < mx + mw and \
                       #~ prop1.value[11] >= mx:
                        #~ strut[3] = max(strut[3], prop1.value[3])
                continue
            if prop2 is not None:
                # Hopefully this one is never needed because
                # it won't work well with dualscreens.
                cl = w.get_wm_class()
                if cl and cl[0] in ("dockx", "dockbarx_factory"):
                    continue
                for i in range(4):
                    strut[i] = max(strut[i], prop2.value[i])
        return strut

    def do_size_allocate(self, allocation):
        CairoDockX.do_size_allocate(self, allocation)
        if self.globals.settings["dock/mode"] == "panel":
            return
        
        w = allocation.width
        h = allocation.height
        sw = self.get_screen().get_width()
        sh = self.get_screen().get_height()
        if self.globals.settings["dock/mode"] == "centered":
            mx, my, mw, mh = self.get_monitor_geometry()
            if self.globals.settings["dock/position"] == "left":
                x = mx
                y = my + mh / 2 - h / 2
            elif self.globals.settings["dock/position"] == "right":
                x = mx + mw - w
                y = my + mh / 2 - h / 2
            elif self.globals.settings["dock/position"] == "top":
                x = mx + mw / 2 - w / 2
                y = my
            else:
                x = mx + mw / 2 - w / 2
                y = my + mh - h
            self.move(x, y)
            self.queue_draw()
        if self.globals.settings["dock/mode"] == "corner":
            x, y = self.get_position()
        self.__set_dock_strut(x, y, w, h)

    def show_dock(self):
        self.show()
        if self.autohide_sid is not None:
            gobject.source_remove(self.autohide_sid)
        if self.autounhide_sid is not None:
            gobject.source_remove(self.autounhide_sid)
            self.autounhide_sid = None
        self.autohide_sid = gobject.timeout_add(200, self.__hide_check)
                                                  
    def hide_dock(self):
        self.hide()
        if self.autohide_sid is not None:
            gobject.source_remove(self.autohide_sid)
            self.autohide_sid = None
        if self.autounhide_sid is not None:
            gobject.source_remove(self.autounhide_sid)
        display = gtk.gdk.display_get_default()
        mx, my, mw, mh = self.get_monitor_geometry()
        if self.globals.settings["dock/position"] == "left":
            x1 = x2 = mx
            y1 = my
            y2 = my + mh -1
        elif self.globals.settings["dock/position"] == "right":
            x1 = x2 = mx + mw - 1
            y1 = my
            y2 = my + mh - 1
        elif self.globals.settings["dock/position"] == "top":
            x1 = mx
            x2 = mx + mh - 1
            y1 = y2 = my
        else:
            x1 = mx
            x2 = mx + mh - 1
            y1 = y2 = my + mh - 1
        self.autounhide_sid = gobject.timeout_add(200, self.__unhide_check,
                                                  display, x1, x2, y1, y2)

    def __unhide_check(self, display, x1, x2, y1, y2):
        if not self.window_overlaps:
            self.show_dock()
            return False
        s, x, y, mod = display.get_pointer()
        if y >= y1 and y <= y2 and x >= x1 and x <= x2:
            self.show_dock()
            return False
        return True

    def __hide_check(self):
        if self.globals.shown_popup() is not None or not self.window_overlaps:
            return True
        pos = self.globals.settings["dock/position"]
        x, y = self.get_pointer()
        a = self.get_allocation()
        if x >= 0 and x < a.width and y >= 0 and y < a.height:
            return True
        if (pos == "left" and x == 0) or \
           (pos == "right" and x == a.width - 1) or \
           (pos == "top" and y == 0)  or \
           (pos == "bottom" and y == a.height - 1):
            return True
        self.hide_dock()
        return False

    def add_window(self, window, calc_overlap=True):
        if not self.globals.settings["dock/autohide"]:
            return
        geo_sid = window.connect("geometry-changed",
                             self.__on_window_geometry_changed)
        state_sid = window.connect("state-changed",
                             self.__on_window_state_changed)
        self.windows[window] = (geo_sid, state_sid)
        self.__calc_border_distance(window)
        if self.db_loaded and calc_overlap:
            self.__calc_window_overlaps()
            
    def remove_window(self, window, calc_overlap=True, forced=False):
        if not self.globals.settings["dock/autohide"] and not forced:
            return
        del self.border_distances[window]
        sids = self.windows.pop(window)
        if sids is not None:
            window.disconnect(sids[0])
            window.disconnect(sids[1])
        if calc_overlap:
            self.__calc_window_overlaps()

    def __on_window_state_changed(self, wnck_window,changed_mask, new_state):
        if WNCK_WINDOW_STATE_MINIMIZED & changed_mask:
            self.__calc_window_overlaps()
        
    def __on_window_geometry_changed(self, window):
        if time.time() - self.geometry_time < 0.12 and \
           window == self.last_geometry_window():
               # Same window get multiple calls when the geometry changes
               # In that case, just return.
               return
        self.last_geometry_window = weakref.ref(window)
        self.geometry_time = time.time()
        gobject.timeout_add(120, self.__calc_border_distance, window, True)
        

    def __calc_border_distance(self, window, calc_overlap=False):
        bd = {"left": 1000, "right": 1000, "top": 1000, "bottom": 1000}
        x, y, w, h = window.get_geometry()
        gdk_screen = gtk.gdk.screen_get_default()
        monitor = gdk_screen.get_monitor_at_point(x + (w / 2), y  + (h / 2))
        if monitor != self.monitor:
            return
        mx, my, mw, mh = self.get_monitor_geometry()
        if y < my + mh and y + h > my:
            if x + w > mx:
                bd["left"] = x - mx
            if x < mx + mw:
                bd["right"] = mx + mw - x - w
        if x < mx + mw and x + w > mx:
            if y + h > my:
                bd["top"] = y - my
            if y < my + mh:
                bd["bottom"] = my + mh - y - h
        self.border_distances[window] = bd
        if calc_overlap:
            self.__calc_window_overlaps()

    def __calc_window_overlaps(self):
        pos = self.globals.settings["dock/position"]
        size = self.globals.settings["dock/size"]
        self.window_overlaps = False
        for window in self.dockbar.windows:
            if window.is_minimized():
                continue
            border_distance = self.border_distances.get(window)
            if border_distance is None:
                continue
            if border_distance[pos] < size:
                self.window_overlaps = True
                break
        return self.window_overlaps
        
        
    def __on_mode_changed(self, *args):
        for child in self.box.get_children():
            self.box.remove(child)
        self.position_dock()
        self.queue_draw()

    def __on_position_changed(self, *args):
        self.position_dock()
        self.queue_draw()
        self.__calc_window_overlaps()
        if self.globals.settings["dock/autohide"]:
            self.hide_dock()

    def __on_overlap_changed(self, *args):
        a = self.get_allocation()
        x, y = self.get_position()
        self.__set_dock_strut(x, y, a.width, a.height)

    def __on_offset_changed(self, *args):
        self.position_dock()

    def __on_autohide_changed(self, *args):
        if self.globals.settings["dock/autohide"]:
            self.hide_dock()
            for window in self.dockbar.windows:
                self.add_window(window, calc_overlap=False)
            self.__calc_window_overlaps()
        else:
            if self.autohide_sid is not None:
                gobject.source_remove(self.autohide_sid)
                self.autohide_sid = None
            if self.autounhide_sid is not None:
                gobject.source_remove(self.autounhide_sid)
                self.autounhide_sid = None
            self.show()
            for window in self.dockbar.windows:
                self.remove_window(window, calc_overlap=False, forced=True)
        self.position_dock()
        if self.globals.settings["dock/mode"] in ("centered", "corner"):
            a = self.get_allocation()
            x, y = self.get_position()
            self.__set_dock_strut(x, y, a.width, a.height)

    def get_monitor_geometry(self):
        screen = self.get_screen()
        if screen is None:
            screen = gtk.gdk.screen_get_default()
        return screen.get_monitor_geometry(self.monitor)

    def reload(self, *args):
        self.db_loaded = False
        self.dockbar.reload()
        self.db_loaded = True
        if self.globals.settings["dock/autohide"]:
            self.__calc_window_overlaps()

    def do_destroy(self, *args):
        CairoDockX.do_destroy(self)
        gtk.main_quit()
        

class EventPadding(gtk.EventBox):
    __gsignals__ = {"button-release-event": "override",
                    "drag-motion" : "override",
                    "drag-leave" : "override",
                    "drag-drop" : "override",
                    "drag-data-received" : "override"}
    def __init__(self, dock, position="after"):
        gtk.EventBox.__init__(self)
        self.globals = Globals()
        self.dock_r = weakref.ref(dock)
        self.set_visible_window(False)
        self.set_size_request(6, 6)

        self.position = position
        self.drag_dest_set(0, [], 0)
        self.drag_entered = False

    def do_button_release_event(self, event):
        if event.button != 3:
            return
        #Create popup menu
        menu = gtk.Menu()
        menu.connect("selection-done", self.__menu_closed)
        preference_item = gtk.ImageMenuItem("gtk-properties", "Preference")
        menu.append(preference_item)
        preference_item.connect("activate", self.__open_preference)
        preference_item.show()
        reload_item = gtk.ImageMenuItem("gtk-refresh", "Reload")
        menu.append(reload_item)
        reload_item.connect("activate", self.__reload)
        reload_item.show()
        about_item = gtk.ImageMenuItem("gtk-about", "About Item")
        menu.append(about_item)
        about_item.connect("activate",
                           lambda e: dockbarx.dockbar.AboutDialog())
        about_item.show()
        close_item = gtk.ImageMenuItem("gtk-close", "Close")
        menu.append(close_item)
        close_item.connect("activate", self.__close_selected)
        close_item.show()
        menu.popup(None, None, None, event.button, event.time)
        self.globals.gtkmenu_showing = True
        
    def __menu_closed(self, menushell):
        self.globals.gtkmenu_showing = False
        menushell.destroy()

    def __close_selected(self, *args):
        self.dock_r().destroy()
        
    def __open_preference(self, *args):
        os.spawnlp(os.P_NOWAIT,"/usr/bin/dbx_preference",
                   "/usr/bin/dbx_preference")

    def __reload(self, *args):
        self.dock_r().reload()

    def do_drag_drop(self, drag_context, x, y, t):
        if "text/groupbutton_name" in drag_context.targets:
            self.drag_get_data(drag_context, "text/groupbutton_name", t)
            drag_context.finish(True, False, t)
        elif "text/uri-list" in drag_context.targets:
            self.drag_get_data(drag_context, "text/uri-list", t)
            drag_context.finish(True, False, t)
        else:
            drag_context.finish(False, False, t)
        return True

    def do_drag_data_received(self, context, x, y, selection, targetType, t):
        if selection.target == "text/groupbutton_name":
            self.dock_r().dockbar.groupbutton_moved(selection.data,
                                                    self.position)
        elif selection.target == "text/uri-list":
            if ".desktop" in selection.data:
                # .desktop file! This is a potential launcher.
                #remove "file://" and "/n" from the URI
                # Todo: What if the uri doesn't start with "file://"?
                path = selection.data[7:-2]
                path = path.replace("%20"," ")
                self.dock_r().dockbar.launcher_dropped(path, self.position)

    def do_drag_motion(self, drag_context, x, y, t):
        if not self.drag_entered:
            self.do_drag_enter(drag_context, x, y, t)
        if "text/groupbutton_name" in drag_context.targets:
            drag_context.drag_status(gtk.gdk.ACTION_MOVE, t)
        elif "text/uri-list" in drag_context.targets:
            drag_context.drag_status(gtk.gdk.ACTION_COPY, t)
        else:
            drag_context.drag_status(gtk.gdk.ACTION_PRIVATE, t)
        return True

    def do_drag_enter(self, drag_context, x, y, t):
        self.drag_entered = True

    def do_drag_leave(self, drag_context, t):
        self.drag_entered = False

class DockXDBus(dbus.service.Object):

    def __init__(self, dockx):
        self.bus_name = "org.dockbar.DockX"
        if "org.dockbar.DockX" in dbus.SessionBus().list_names():
            for n in range(1, 100):
                name = "org.dockbar.DockX%s" % n
                if not name in dbus.SessionBus().list_names():
                    self.bus_name = name
                    break
        self.dockx_r = weakref.ref(dockx)
        bus_name = dbus.service.BusName(self.bus_name,
                                        bus = dbus.SessionBus())
        dbus.service.Object.__init__(self, bus_name,
                                     "/org/dockbar/DockX")

    @dbus.service.method(dbus_interface="org.dockbar.DockX",
                         in_signature="", out_signature="",)
    def Reload(self):
        self.dockx_r().reload()

    @dbus.service.method(dbus_interface=dbus.PROPERTIES_IFACE,
                         in_signature='ss', out_signature='v')
    def Get(self, interface_name, property_name):
        return self.GetAll(interface_name)[property_name]

    @dbus.service.method(dbus_interface=dbus.PROPERTIES_IFACE,
                         in_signature='s', out_signature='a{sv}')
    def GetAll(self, interface_name):
        if interface_name == "org.dockbar.DockX":
            return {}
        else:
            raise dbus.exceptions.DBusException(
                'com.example.UnknownInterface',
                'The Foo object does not implement the %s interface'
                    % interface_name)

    @dbus.service.method(dbus_interface=dbus.PROPERTIES_IFACE,
                         in_signature='ssv', out_signature='')
    def Set(self, interface_name, property_name, property_value):
        pass

    @dbus.service.signal(dbus_interface=dbus.PROPERTIES_IFACE,
                         signature='sa{sv}as')
    def PropertiesChanged(self, interface_name, changed_properties,
                          invalidated_properties):
        pass

monitor = 0
if "--monitor" in sys.argv:
    i = sys.argv.index("--monitor") + 1
    try:
        monitor = int(sys.argv[i])
    except:
        raise
dockx = DockX(monitor)
del monitor
gtk.main()
        

