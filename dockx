#!/usr/bin/python

#   DockX
#
#	Copyright 2008, 2009, 2010 Aleksey Shaferov and Matias Sars
#
#	DockbarX is free software: you can redistribute it and/or modify
#	it under the terms of the GNU General Public License as published by
#	the Free Software Foundation, either version 3 of the License, or
#	(at your option) any later version.
#
#	DockbarX is distributed in the hope that it will be useful,
#	but WITHOUT ANY WARRANTY; without even the implied warranty of
#	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#	GNU General Public License for more details.
#
#	You should have received a copy of the GNU General Public License
#	along with dockbar.  If not, see <http://www.gnu.org/licenses/>.

from dockbarx.log import *
import sys
log_to_file()
sys.stderr = StdErrWrapper()
sys.stdout = StdOutWrapper()

import pygtk
pygtk.require("2.0")
import gtk
import cairo
import dockbarx.dockbar
import wnck
from dockbarx.common import Globals
from Xlib import display
from math import pi
import weakref

class CairoDockX(gtk.Window):
    """The Dock Window for running DockbarX as a standalone dock"""
    __gsignals__ = {"expose-event": "override"}
    def __init__(self):
        gtk.Window.__init__(self)
        self.globals = globals()
        self.set_type_hint(gtk.gdk.WINDOW_TYPE_HINT_DOCK)
        self.set_decorated(False)
        self.set_resizable(False)
        gtk_screen = gtk.gdk.screen_get_default()
        colormap = gtk_screen.get_rgba_colormap()
        if colormap is None:
            colormap = gtk_screen.get_rgb_colormap()
        self.set_colormap(colormap)
        self.set_app_paintable(1)
        self.globals = Globals()


    def do_expose_event(self, event):
        self.window.set_back_pixmap(None, False)
        self.set_shape_mask()
        w,h = self.get_size()
        self.ctx = self.window.cairo_create()
        # set a clip region for the expose event, XShape stuff
        self.ctx.save()
        if self.is_composited():
            self.ctx.set_source_rgba(1, 1, 1,0)
        else:
            self.ctx.set_source_rgb(0.8, 0.8, 0.8)
        self.ctx.set_operator(cairo.OPERATOR_SOURCE)
        self.ctx.paint()
        self.ctx.restore()
        self.ctx.rectangle(event.area.x, event.area.y,
                           event.area.width, event.area.height)
        self.ctx.clip()
        self.draw_frame(self.ctx, w, h)
        gtk.Window.do_expose_event(self, event)
        #~ if self.get_child():
            #~ self.propagate_expose(self.get_child(), event)

    def set_shape_mask(self):
        # Set window shape from alpha mask of background image
        #~ w,h = self.get_size()
        #~ if w==0: w = 800
        #~ if h==0: h = 600
        #~ pixmap = gtk.gdk.Pixmap (None, w, h, 1)
        #~ ctx = pixmap.cairo_create()
        #~ ctx.set_source_rgba(0, 0, 0,0)
        #~ ctx.set_operator (cairo.OPERATOR_SOURCE)
        #~ ctx.paint()
        #~ if self.is_composited():
            #~ make_path(ctx, 0, 0, w, h, 6, 0, 9, self.pointer, self.ap)
            #~ ctx.set_source_rgba(1, 1, 1, 1)
        #~ else:
            #~ make_path(ctx, 0, 0, w, h, 6, 1, 9, self.pointer, self.ap)
            #~ ctx.set_source_rgb(0, 0, 0)
        #~ ctx.fill()
        #~ self.shape_combine_mask(pixmap, 0, 0)
        #~ del pixmap
        pass

    def draw_frame(self, ctx, w, h):
        color = self.globals.colors["color1"]
        red = float(int(color[1:3], 16))/255
        green = float(int(color[3:5], 16))/255
        blue = float(int(color[5:7], 16))/255
        alpha= float(self.globals.colors["color1_alpha"]) / 255
        mode = self.globals.settings["dock/mode"]
        pos = self.globals.settings["dock/position"]
        r = 6
        # Create the stroke and fill paths
        if pos == "left":
            if mode == "centered":
                ctx.move_to(0, 0.5)
                ctx.arc(w - r - 0.5, r + 0.5, r, -pi/2, 0)
            else:
                ctx.move_to(w - 0.5, 0)
            if mode == "centered" or mode == "corner":
                ctx.arc(w - r - 0.5, h - r - 0.5, r, 0, pi/2)
                ctx.line_to(0, h - 0.5)
            else:
                ctx.line_to(w - 0.5, h)
            stroke_path = ctx.copy_path()
            ctx.line_to(0, h)
            ctx.line_to(0, 0)
            ctx.close_path()
        elif pos == "right":
            if mode == "centered":
                ctx.move_to(w, 0.5)
                ctx.arc_negative(r + 0.5, r + 0.5, r, -pi/2, -pi)
            else:
                ctx.move_to(0.5, 0)
            if mode == "centered" or mode == "corner":
                ctx.arc_negative(r + 0.5, h - r - 0.5, r, pi, pi/2)
                ctx.line_to(w, h - 0.5)
            else:
                ctx.line_to(0.5, h)
            stroke_path = ctx.copy_path()
            ctx.line_to(w, h)
            ctx.line_to(w, 0)
            ctx.close_path()
        elif pos == "top":
            if mode == "centered":
                ctx.move_to(0.5, 0)
                ctx.arc_negative(r + 0.5, h - r - 0.5, r, pi, pi/2)
            else:
                ctx.move_to(0, h - 0.5)
            if mode == "centered" or mode == "corner":
                ctx.arc_negative(w - r - 0.5, h - r - 0.5, r, pi/2, 0)
                ctx.line_to(w - 0.5, 0)
            else:
                ctx.line_to(w, h - 0.5)
            stroke_path = ctx.copy_path()
            ctx.line_to(w, 0)
            ctx.line_to(0, 0)
            ctx.close_path()
        else:
            if mode == "centered":
                ctx.move_to(0.5, h)
                ctx.arc(r + 0.5, r + 0.5, r, -pi, -pi/2)
            else:
                ctx.move_to(0, 0.5)
            if mode == "centered" or mode == "corner":
                ctx.arc(w - r - 0.5, r + 0.5, r, -pi/2, 0)
                ctx.line_to(w - 0.5, h)
            else:
                ctx.line_to(w, 0.5)
            stroke_path = ctx.copy_path()
            ctx.line_to(w, h)
            ctx.line_to(0, h)
            ctx.close_path()
        # Fill with background color
        if self.is_composited():
            ctx.set_source_rgba(red, green, blue, alpha)
        else:
            ctx.set_source_rgb(red, green, blue)
        ctx.fill()
        # Stroke the outer border
        ctx.append_path(stroke_path)
        if self.is_composited():
            ctx.set_source_rgba(red*0.5, green*0.5, blue*0.5, 0.8)
        else:
            ctx.set_source_rgb(red*0.5, green*0.5, blue*0.5)
        ctx.set_line_width(1)
        ctx.stroke()

        
class DockX(CairoDockX):
    __gsignals__ = {"destroy": "override",
                    "size-allocate": "override"}
    def __init__(self):
        self.globals = Globals()
        self.dockbar = dockbarx.dockbar.DockBar(None,
                                                parent_window=self,
                                                run_as_dock=True)
        self.dockbar.load()
        CairoDockX.__init__(self)
        self.box = gtk.HBox()
        self.event_box1 = EventPadding(self)
        self.event_box2 = EventPadding(self)
        self.add(self.box)
        self.position_dock()
        self.globals.connect("dock-size-changed", self.position_dock)
        self.globals.connect("dock-position-changed",
                             self.__on_position_changed)
        self.globals.connect("dock-mode-changed", self.__on_mode_changed)

    def position_dock(self, *args):
        monitor = self.get_screen().get_monitor_geometry(0)
        size = self.globals.settings["dock/size"]
        centered = self.globals.settings["dock/mode"] == "centered"
        cornered = self.globals.settings["dock/mode"] == "corner"
        pos = self.globals.settings["dock/position"]
        mx, my, mw, mh = monitor
        l, r, t, b = self.__get_strut()
        if self.globals.settings["dock/position"] in ("left", "right"):
            if self.globals.orient != "v" or not self.box.get_children():
                self.dockbar.set_orient("v")
                for child in self.box.get_children():
                    self.box.remove(child)
                self.box.destroy()
                self.box = gtk.VBox()
                self.add(self.box)
                if centered:
                    self.box.pack_start(self.event_box1, False, False)
                self.box.pack_start(self.dockbar.container, False, False)
                if centered or cornered:
                    self.box.pack_start(self.event_box2, False, False)
                else:
                    self.box.pack_start(self.event_box2, True, True)
                self.show_all()
        else:
            if self.globals.orient != "h" or not self.box.get_children():
                self.dockbar.set_orient("h")
                for child in self.box.get_children():
                    self.box.remove(child)
                self.box.destroy()
                self.box = gtk.HBox()
                self.add(self.box)
                if centered:
                    self.box.pack_start(self.event_box1, False, False)
                self.box.pack_start(self.dockbar.container, False, False)
                if centered or cornered:
                    self.box.pack_start(self.event_box2, False, False)
                else:
                    self.box.pack_start(self.event_box2, True, True)
                self.show_all()
        if pos == "left":
            x,y, w, h = (mx + l, my + t, size, mh - t - b)
            strut = [size, 0, 0, 0, y, y + h - 1, 0, 0, 0, 0, 0, 0]
        elif pos == "right":
            x,y, w, h = (mx + mw - size - r, my - t, size, mh - t - b)
            strut = [0, size, 0, 0, 0, 0, y, y + h - 1, 0, 0, 0, 0]
        elif pos == "top":
            x,y, w, h = (mx + l, my + t, mw - l - r, size)
            strut = [0, 0, size, 0, 0, 0, 0, 0, x, x + w - 1, 0, 0]
        else:
            x,y, w, h = (mx + l, my + mh - size - b, mw - l - r, size)
            strut = [0, 0, 0, size, 0, 0, 0, 0, 0, 0, x, x + w - 1]
        if (centered or cornered) and pos in ("left", "right"):
            self.set_size_request(w, -1)
        elif (centered or cornered):
            self.set_size_request(-1, h)
        else:
            self.set_size_request(w, h)
        if centered and pos in ("left", "right"):
            a = self.get_allocation()
            self.move(x, my + mh / 2 - a.height / 2)
        elif centered:
            a = self.get_allocation()
            self.move(mx + mw / 2 - a.width / 2, y)
        else:
            self.move(x, y)
        if self.window:
            self.window.property_change("_NET_WM_STRUT", "CARDINAL", 32, 
                                        gtk.gdk.PROP_MODE_REPLACE, strut[:4])  
            self.window.property_change("_NET_WM_STRUT_PARTIAL", "CARDINAL", 
                                        32, gtk.gdk.PROP_MODE_REPLACE, strut)
        for group in self.dockbar.groups:
            group.button.icon_factory.set_size(size)
            group.button.update_state(force_update=True)

    def __get_strut(self):
        monitor = self.get_screen().get_monitor_geometry(0)
        size = self.globals.settings["dock/size"]
        mx, my, mw, mh = monitor
        d = display.Display()
        root = d.screen().root
        windows = root.query_tree()._data['children']
        strut_atom = d.get_atom('_NET_WM_STRUT')
        strut_partial_atom = d.get_atom('_NET_WM_STRUT_PARTIAL')
        strut = [0, 0, 0, 0]
        for w in windows:
            prop1 = w.get_full_property(strut_partial_atom, 0)
            prop2 = w.get_full_property(strut_atom, 0)
            if prop1 is not None:
                cl = w.get_wm_class()
                if cl and cl[0] in ("dockx", "dockbarx_factory"):
                    continue
                if self.globals.settings["dock/position"] == "left":
                    strut[0] = max(strut[0], prop1.value[0])
                    strut[1] = max(strut[1], prop1.value[1])
                    if prop1.value[8] <= size:
                        strut[2] = max(strut[2], prop1.value[2])
                    if prop1.value[10] <= size:
                        strut[3] = max(strut[3], prop1.value[3])
                elif self.globals.settings["dock/position"] == "right":
                    strut[0] = max(strut[0], prop1.value[0])
                    strut[1] = max(strut[1], prop1.value[1])
                    if prop1.value[9] >= mw - size:
                        strut[2] = max(strut[2], prop1.value[2])
                    if prop1.value[11] >= mw - size:
                        strut[3] = max(strut[3], prop1.value[3])
                        strut[3] = max(strut[3], prop1.value[3])
                elif self.globals.settings["dock/position"] == "top":
                    if prop1.value[4] <= size:
                        strut[0] = max(strut[0], prop1.value[0])
                    if prop1.value[6] <= size:
                        strut[1] = max(strut[1], prop1.value[1])
                    strut[2] = max(strut[2], prop1.value[2])
                    strut[3] = max(strut[3], prop1.value[3])
                else:
                    if prop1.value[5] >= mh - size:
                        strut[0] = max(strut[0], prop1.value[0])
                    if prop1.value[7] >= mh - size:
                        strut[1] = max(strut[1], prop1.value[1])
                    strut[2] = max(strut[2], prop1.value[2])
                    strut[3] = max(strut[3], prop1.value[3])
                continue
            if prop2 is not None:
                cl = w.get_wm_class()
                if cl and cl[0] in ("dockx", "dockbarx_factory"):
                    continue
                for i in range(4):
                    strut[i] = max(strut[i], prop2.value[i])
        return strut

    def do_size_allocate(self, allocation):
        CairoDockX.do_size_allocate(self, allocation)
        if self.globals.settings["dock/mode"] != "centered":
            return
        monitor = self.get_screen().get_monitor_geometry(0)
        mx, my, mw, mh = monitor
            
        if self.globals.settings["dock/position"] == "left":
            x = mx
            y = my + mh / 2 - allocation.height / 2
        elif self.globals.settings["dock/position"] == "right":
            x = mx + mw - allocation.width
            y = my + mh / 2 - allocation.height / 2
        elif self.globals.settings["dock/position"] == "top":
            x = mx + mw / 2 - allocation.width / 2
            y = 0
        else:
            x = mx + mw / 2 - allocation.width / 2
            y = my + mh - allocation.height
        self.move(x, y)
        self.queue_draw()

    def __on_mode_changed(self, *args):
        for child in self.box.get_children():
            self.box.remove(child)
        self.position_dock()
        self.queue_draw()

    def __on_position_changed(self, *args):
        self.position_dock()
        self.queue_draw()

    def reload(self, *args):
        self.dockbar.reload() 

    def do_destroy(self, *args):
        CairoDockX.do_destroy(self)
        gtk.main_quit()
        

class EventPadding(gtk.EventBox):
    __gsignals__ = {"button-release-event": "override"}
    def __init__(self, dock):
        gtk.EventBox.__init__(self)
        self.globals = Globals()
        self.dock_r = weakref.ref(dock)
        self.set_visible_window(False)
        self.set_size_request(6, 6)

    def do_button_release_event(self, event):
        if event.button != 3:
            return
        #Create popup menu
        menu = gtk.Menu()
        menu.connect("selection-done", self.__menu_closed)
        preference_item = gtk.ImageMenuItem("gtk-properties", "Preference")
        menu.append(preference_item)
        preference_item.connect("activate", self.__open_preference)
        preference_item.show()
        reload_item = gtk.ImageMenuItem("gtk-refresh", "Reload")
        menu.append(reload_item)
        reload_item.connect("activate", self.__reload)
        reload_item.show()
        about_item = gtk.ImageMenuItem("gtk-about", "About Item")
        menu.append(about_item)
        about_item.connect("activate",
                           lambda e: dockbarx.dockbar.AboutDialog())
        about_item.show()
        close_item = gtk.ImageMenuItem("gtk-close", "Close")
        menu.append(close_item)
        close_item.connect("activate", self.__close_selected)
        close_item.show()
        menu.popup(None, None, None, event.button, event.time)
        self.globals.gtkmenu_showing = True
        
    def __menu_closed(self, menushell):
        self.globals.gtkmenu_showing = False
        menushell.destroy()

    def __close_selected(self, *args):
        self.dock_r().destroy()
        
    def __open_preference(self, *args):
        os.spawnlp(os.P_NOWAIT,"/usr/bin/dbx_preference",
                   "/usr/bin/dbx_preference")

    def __reload(self, *args):
        self.dock_r().reload()

def shift(l, n=1):
    return l[n:] + l[:n]
dockx = DockX()
gtk.main()
        

