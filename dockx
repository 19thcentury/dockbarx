#!/usr/bin/python

#   DockX
#
#	Copyright 2008, 2009, 2010 Aleksey Shaferov and Matias Sars
#
#	DockbarX is free software: you can redistribute it and/or modify
#	it under the terms of the GNU General Public License as published by
#	the Free Software Foundation, either version 3 of the License, or
#	(at your option) any later version.
#
#	DockbarX is distributed in the hope that it will be useful,
#	but WITHOUT ANY WARRANTY; without even the implied warranty of
#	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#	GNU General Public License for more details.
#
#	You should have received a copy of the GNU General Public License
#	along with dockbar.  If not, see <http://www.gnu.org/licenses/>.

from dockbarx.log import *
import sys
#log_to_file()
#sys.stderr = StdErrWrapper()
#sys.stdout = StdOutWrapper()

import pygtk
pygtk.require("2.0")
import gtk
import gnomeapplet
import cairo
import dockbarx.dockbar
import wnck
from dockbarx.common import Globals
from Xlib import display

class CairoDockX(gtk.Window):
    """The Dock Window for running DockbarX as a standalone dock"""
    __gsignals__ = {"expose-event": "override"}
    def __init__(self):
        gtk.Window.__init__(self)
        self.globals = globals()
        self.set_type_hint(gtk.gdk.WINDOW_TYPE_HINT_DOCK)
        self.set_decorated(False)
        gtk_screen = gtk.gdk.screen_get_default()
        colormap = gtk_screen.get_rgba_colormap()
        if colormap is None:
            colormap = gtk_screen.get_rgb_colormap()
        self.set_colormap(colormap)
        self.set_app_paintable(1)
        self.globals = Globals()


    def do_expose_event(self, event):
        self.window.set_back_pixmap(None, False)
        self.set_shape_mask()
        w,h = self.get_size()
        self.ctx = self.window.cairo_create()
        # set a clip region for the expose event, XShape stuff
        self.ctx.save()
        if self.is_composited():
            self.ctx.set_source_rgba(1, 1, 1,0)
        else:
            self.ctx.set_source_rgb(0.8, 0.8, 0.8)
        self.ctx.set_operator(cairo.OPERATOR_SOURCE)
        self.ctx.paint()
        self.ctx.restore()
        self.ctx.rectangle(event.area.x, event.area.y,
                           event.area.width, event.area.height)
        self.ctx.clip()
        self.draw_frame(self.ctx, w, h)
        gtk.Window.do_expose_event(self, event)
        #~ if self.get_child():
            #~ self.propagate_expose(self.get_child(), event)

    def set_shape_mask(self):
        # Set window shape from alpha mask of background image
        #~ w,h = self.get_size()
        #~ if w==0: w = 800
        #~ if h==0: h = 600
        #~ pixmap = gtk.gdk.Pixmap (None, w, h, 1)
        #~ ctx = pixmap.cairo_create()
        #~ ctx.set_source_rgba(0, 0, 0,0)
        #~ ctx.set_operator (cairo.OPERATOR_SOURCE)
        #~ ctx.paint()
        #~ if self.is_composited():
            #~ make_path(ctx, 0, 0, w, h, 6, 0, 9, self.pointer, self.ap)
            #~ ctx.set_source_rgba(1, 1, 1, 1)
        #~ else:
            #~ make_path(ctx, 0, 0, w, h, 6, 1, 9, self.pointer, self.ap)
            #~ ctx.set_source_rgb(0, 0, 0)
        #~ ctx.fill()
        #~ self.shape_combine_mask(pixmap, 0, 0)
        #~ del pixmap
        pass

    def draw_frame(self, ctx, w, h):
        color = self.globals.colors["color1"]
        red = float(int(color[1:3], 16))/255
        green = float(int(color[3:5], 16))/255
        blue = float(int(color[5:7], 16))/255
        alpha= float(self.globals.colors["color1_alpha"]) / 255
        if self.globals.settings["dock/position"] == "left":
            x0, y0, x1, y1 = (w - 0.5, 0.5, w - 0.5, h - 0.5)
        elif self.globals.settings["dock/position"] == "right":
            x0, y0, x1, y1 = (0.5, 0.5, 0.5, h - 0.5)
        elif self.globals.settings["dock/position"] == "top":
            x0, y0, x1, y1 = (0.5, h - 0.5, w - 0.5, h - 0.5)
        else:
            x0, y0, x1, y1 = (0.5, 0.5, w - 0.5, 0.5)
            
        if self.is_composited():
            ctx.set_source_rgba(red, green, blue, alpha)
        else:
            ctx.set_source_rgb(red, green, blue)
        ctx.paint()
        if self.is_composited():
            ctx.set_source_rgba(red*0.5, green*0.5, blue*0.5, 0.8)
        else:
            ctx.set_source_rgb(0, 0, 0)
        ctx.set_line_width(1)
        ctx.move_to(x0, y0)
        ctx.line_to(x1, y1)
        ctx.stroke()

        
class DockX(CairoDockX):
    __gsignals__ = {"destroy": "override"}
    def __init__(self):
        self.globals = Globals()
        self.dockbar = dockbarx.dockbar.DockBar(None,
                                                parent_window=self,
                                                run_as_dock=True)
        self.dockbar.monitor = 0
        self.dockbar.reload()
        CairoDockX.__init__(self)
        self.box = gtk.HBox()
        self.add(self.box)
        self.event_box = gtk.EventBox()
        self.event_box.set_visible_window(False)
        self.box.pack_start(self.dockbar.container, False, False)
        self.box.pack_end(self.event_box, True, True)
        self.position_dock()
        self.show_all()
        size = self.globals.settings["dock/size"]
        # For the strut. Window isn't realised first time.
        self.position_dock()
        self.globals.connect("dock-size-changed", self.position_dock)
        self.globals.connect("dock-position-changed", self.position_dock)
        #~ self.globals.connect("dock-mode-changed", self.position_dock)
        self.event_box.connect("button-release-event", self.__show_menu)

    def position_dock(self, *args):
        monitor = self.get_screen().get_monitor_geometry(0)
        size = self.globals.settings["dock/size"]
        mx, my, mw, mh = monitor
        l, r, t, b = self.__get_strut()
        if self.globals.settings["dock/position"] in ("left", "right"):
            if self.globals.orient != "v":
                self.dockbar.set_orient("v")
                self.box.remove(self.event_box)
                self.box.destroy()
                self.box = gtk.VBox()
                self.add(self.box)
                self.box.pack_start(self.dockbar.container, False, False)
                self.box.pack_start(self.event_box, True, True)
                self.show_all()
        else:
            if self.globals.orient != "h":
                self.dockbar.set_orient("h")
                self.box.remove(self.event_box)
                self.box.destroy()
                self.box = gtk.HBox()
                self.add(self.box)
                self.box.pack_start(self.dockbar.container, False, False)
                self.box.pack_start(self.event_box, True, True)
                self.show_all()
        if self.globals.settings["dock/position"] == "left":
            x,y, w, h = (mx + l, my + t, size, mh - t - b)
            strut = [size, 0, 0, 0, y, y + h - 1, 0, 0, 0, 0, 0, 0]
        elif self.globals.settings["dock/position"] == "right":
            x,y, w, h = (mx + mw - size - r, my - t, size, mh - t - b)
            strut = [0, size, 0, 0, 0, 0, y, y + h - 1, 0, 0, 0, 0]
        elif self.globals.settings["dock/position"] == "top":
            x,y, w, h = (mx + l, my + t, mw - l - r, size)
            strut = [0, 0, size, 0, 0, 0, 0, 0, x, x + w - 1, 0, 0]
        else:
            x,y, w, h = (mx + l, my + mh - size - b, mw - l - r, size)
            strut = [0, 0, 0, size, 0, 0, 0, 0, 0, 0, x, x + w - 1]
        self.move(x, y)
        self.resize(w, h)
        if self.window:
            self.window.property_change("_NET_WM_STRUT", "CARDINAL", 32, 
                                        gtk.gdk.PROP_MODE_REPLACE, strut[:4])  
            self.window.property_change("_NET_WM_STRUT_PARTIAL", "CARDINAL", 
                                        32, gtk.gdk.PROP_MODE_REPLACE, strut)
        for group in self.dockbar.groups:
            group.button.icon_factory.set_size(size)
            group.button.update_state(force_update=True)

    def __get_strut(self):
        monitor = self.get_screen().get_monitor_geometry(0)
        size = self.globals.settings["dock/size"]
        mx, my, mw, mh = monitor
        d = display.Display()
        root = d.screen().root
        windows = root.query_tree()._data['children']
        strut_atom = d.get_atom('_NET_WM_STRUT')
        strut_partial_atom = d.get_atom('_NET_WM_STRUT_PARTIAL')
        strut = [0, 0, 0, 0]
        for w in windows:
            prop1 = w.get_full_property(strut_partial_atom, 0)
            prop2 = w.get_full_property(strut_atom, 0)
            if prop1 is not None:
                cl = w.get_wm_class()
                if cl and cl[0] in ("dockx", "dockbarx_factory"):
                    continue
                if self.globals.settings["dock/position"] == "left":
                    strut[0] = max(strut[0], prop1.value[0])
                    strut[1] = max(strut[1], prop1.value[1])
                    if prop1.value[8] <= size:
                        strut[2] = max(strut[2], prop1.value[2])
                    if prop1.value[10] <= size:
                        strut[3] = max(strut[3], prop1.value[3])
                elif self.globals.settings["dock/position"] == "right":
                    strut[0] = max(strut[0], prop1.value[0])
                    strut[1] = max(strut[1], prop1.value[1])
                    if prop1.value[9] >= mw - size:
                        strut[2] = max(strut[2], prop1.value[2])
                    if prop1.value[11] >= mw - size:
                        strut[3] = max(strut[3], prop1.value[3])
                        strut[3] = max(strut[3], prop1.value[3])
                elif self.globals.settings["dock/position"] == "top":
                    if prop1.value[4] <= size:
                        strut[0] = max(strut[0], prop1.value[0])
                    if prop1.value[6] <= size:
                        strut[1] = max(strut[1], prop1.value[1])
                    strut[2] = max(strut[2], prop1.value[2])
                    strut[3] = max(strut[3], prop1.value[3])
                else:
                    if prop1.value[5] >= mh - size:
                        strut[0] = max(strut[0], prop1.value[0])
                    if prop1.value[7] >= mh - size:
                        strut[1] = max(strut[1], prop1.value[1])
                    strut[2] = max(strut[2], prop1.value[2])
                    strut[3] = max(strut[3], prop1.value[3])
                continue
            if prop2 is not None:
                cl = w.get_wm_class()
                if cl and cl[0] in ("dockx", "dockbarx_factory"):
                    continue
                for i in range(4):
                    strut[i] = max(strut[i], prop2.value[i])
        return strut

    def __reload(self, *args):
        self.dockbar.reload()
                
    def __show_menu(self, widget, event):
        if event.button != 3:
            return
        #Creates a popup menu
        menu = gtk.Menu()
        menu.connect("selection-done", self.__menu_closed)
        preference_item = gtk.ImageMenuItem("gtk-properties", "Preference")
        menu.append(preference_item)
        preference_item.connect("activate", self.__open_preference)
        preference_item.show()
        reload_item = gtk.ImageMenuItem("gtk-refresh", "Reload")
        menu.append(reload_item)
        reload_item.connect("activate", self.__reload)
        reload_item.show()
        about_item = gtk.ImageMenuItem("gtk-about", "About Item")
        menu.append(about_item)
        about_item.connect("activate", lambda e: dockbarx.dockbar.AboutDialog())
        about_item.show()
        close_item = gtk.ImageMenuItem("gtk-close", "Close")
        menu.append(close_item)
        close_item.connect("activate", self.do_destroy)
        close_item.show()
        menu.popup(None, None, None, event.button, event.time)
        self.globals.gtkmenu_showing = True

    def __menu_closed(self, menushell):
        self.globals.gtkmenu_showing = False
        menushell.destroy()
        
    def do_destroy(self, *args):
        CairoDockX.do_destroy(self)
        gtk.main_quit()

    def __open_preference(self, *args):
        os.spawnlp(os.P_NOWAIT,"/usr/bin/dbx_preference",
                   "/usr/bin/dbx_preference")

dockx = DockX()
gtk.main()
        

